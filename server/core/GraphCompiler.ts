import { graphValidator } from './GraphValidator';

export interface CompilerOptions {
  projectName?: string;
  includeLogging?: boolean;
  includeErrorHandling?: boolean;
  optimizeForPerformance?: boolean;
}

export interface CompiledFile {
  name: string;
  content: string;
  type: 'js' | 'json' | 'html';
}

export interface CompilerResult {
  files: CompiledFile[];
  manifest: any;
  entry: string;
  estimatedSize: number;
  requiredScopes: string[];
}

export class GraphCompiler {
  
  /**
   * Compiles a NodeGraph into Google Apps Script files
   */
  public compile(graph: any, options: CompilerOptions = {}): CompilerResult {
    // First validate the graph
    const validation = graphValidator.validate(graph);
    if (!validation.valid) {
      throw new Error(`Cannot compile invalid graph: ${validation.errors.map(e => e.message).join(', ')}`);
    }

    console.log(`ðŸ”¨ Compiling graph: ${graph.name}`);

    const files: CompiledFile[] = [];
    const projectName = options.projectName || graph.name || 'AutomationScript';

    // 1. Generate main Code.js file
    const mainCode = this.generateMainCode(graph, options);
    files.push({
      name: 'Code.js',
      content: mainCode,
      type: 'js'
    });

    // 2. Generate helper files
    const helperFiles = this.generateHelperFiles(graph, options);
    files.push(...helperFiles);

    // 3. Generate appsscript.json manifest
    const manifest = this.generateManifest(graph, validation.requiredScopes, options);
    files.push({
      name: 'appsscript.json',
      content: JSON.stringify(manifest, null, 2),
      type: 'json'
    });

    // 4. Generate trigger setup if needed
    const triggerSetup = this.generateTriggerSetup(graph);
    if (triggerSetup) {
      files.push({
        name: 'TriggerSetup.js',
        content: triggerSetup,
        type: 'js'
      });
    }

    // Calculate total size
    const estimatedSize = files.reduce((total, file) => total + file.content.length, 0);

    return {
      files,
      manifest,
      entry: 'Code.js',
      estimatedSize,
      requiredScopes: validation.requiredScopes
    };
  }

  /**
   * Generates the main Code.js file with the workflow execution logic
   */
  private generateMainCode(graph: any, options: CompilerOptions): string {
    const nodes = graph.nodes || [];
    const edges = graph.edges || [];
    
    // Build execution order using topological sort
    const executionOrder = this.getExecutionOrder(nodes, edges);
    
    let code = `/**
 * ${graph.name || 'Automation Script'}
 * Generated by Apps Script Studio
 * ${new Date().toISOString()}
 */

// Global configuration
const CONFIG = {
  projectName: '${graph.name || 'AutomationScript'}',
  version: '1.0.0',
  logging: ${options.includeLogging !== false},
  errorHandling: ${options.includeErrorHandling !== false}
};

// Main execution function
function runWorkflow(triggerData = {}) {
  try {
    Logger.log('ðŸš€ Starting workflow: ' + CONFIG.projectName);
    
    // Initialize workflow context
    const context = {
      triggerData: triggerData,
      results: {},
      errors: [],
      startTime: new Date()
    };
    
    // Execute nodes in order
${executionOrder.map(nodeId => {
  const node = nodes.find(n => n.id === nodeId);
  return `    executeNode_${nodeId}(context);`;
}).join('\n')}
    
    // Log completion
    const duration = new Date().getTime() - context.startTime.getTime();
    Logger.log(\`âœ… Workflow completed in \${duration}ms\`);
    
    return {
      success: true,
      results: context.results,
      duration: duration
    };
    
  } catch (error) {
    Logger.log('âŒ Workflow error: ' + error.toString());
    ${options.includeErrorHandling !== false ? `
    // Send error notification if configured
    if (typeof sendErrorNotification === 'function') {
      sendErrorNotification(error, CONFIG.projectName);
    }` : ''}
    
    throw error;
  }
}

// Node execution functions
${nodes.map(node => this.generateNodeFunction(node)).join('\n\n')}

// Utility functions
${this.generateUtilityFunctions(options)}
`;

    return code;
  }

  /**
   * Generates execution function for a specific node
   */
  private generateNodeFunction(node: any): string {
    const nodeId = node.id;
    const nodeType = node.type;
    const nodeData = node.data || {};

    let functionCode = `function executeNode_${nodeId}(context) {
  try {
    Logger.log('Executing node: ${nodeId} (${nodeType})');
    
`;

    // Generate node-specific code based on type
    switch (nodeType) {
      case 'gmail.send':
        functionCode += this.generateGmailSendCode(nodeData);
        break;
      case 'gmail.read':
        functionCode += this.generateGmailReadCode(nodeData);
        break;
      case 'sheets.append':
        functionCode += this.generateSheetsAppendCode(nodeData);
        break;
      case 'sheets.read':
        functionCode += this.generateSheetsReadCode(nodeData);
        break;
      case 'drive.create':
        functionCode += this.generateDriveCreateCode(nodeData);
        break;
      case 'http.request':
        functionCode += this.generateHttpRequestCode(nodeData);
        break;
      case 'condition.if':
        functionCode += this.generateConditionCode(nodeData);
        break;
      case 'transform.data':
        functionCode += this.generateTransformCode(nodeData);
        break;
      case 'utility.delay':
        functionCode += this.generateDelayCode(nodeData);
        break;
      default:
        functionCode += `    // Unsupported node type: ${nodeType}
    Logger.log('âš ï¸ Unsupported node type: ${nodeType}');`;
    }

    functionCode += `
    
    // Store result in context
    context.results['${nodeId}'] = result;
    Logger.log('âœ… Node ${nodeId} completed');
    
  } catch (error) {
    Logger.log('âŒ Node ${nodeId} failed: ' + error.toString());
    context.errors.push({
      nodeId: '${nodeId}',
      error: error.toString(),
      timestamp: new Date()
    });
    throw error;
  }
}`;

    return functionCode;
  }

  /**
   * Generate Gmail send code
   */
  private generateGmailSendCode(data: any): string {
    return `    const result = GmailApp.sendEmail(
      '${data.to || ''}',
      '${data.subject || 'Automated Email'}',
      '${data.body || ''}',
      {
        htmlBody: '${data.htmlBody || ''}',
        attachments: ${JSON.stringify(data.attachments || [])},
        cc: '${data.cc || ''}',
        bcc: '${data.bcc || ''}'
      }
    );`;
  }

  /**
   * Generate Gmail read code
   */
  private generateGmailReadCode(data: any): string {
    return `    const threads = GmailApp.search('${data.query || 'is:unread'}', 0, ${data.maxResults || 10});
    const result = threads.map(thread => {
      const messages = thread.getMessages();
      return messages.map(message => ({
        subject: message.getSubject(),
        from: message.getFrom(),
        body: message.getBody(),
        date: message.getDate(),
        id: message.getId()
      }));
    }).flat();`;
  }

  /**
   * Generate Sheets append code
   */
  private generateSheetsAppendCode(data: any): string {
    return `    const sheet = SpreadsheetApp.openById('${data.spreadsheetId}').getSheetByName('${data.sheetName || 'Sheet1'}');
    const values = ${JSON.stringify(data.values || [])};
    const result = sheet.appendRow(values);`;
  }

  /**
   * Generate Sheets read code
   */
  private generateSheetsReadCode(data: any): string {
    return `    const sheet = SpreadsheetApp.openById('${data.spreadsheetId}').getSheetByName('${data.sheetName || 'Sheet1'}');
    const range = '${data.range || 'A:Z'}';
    const result = sheet.getRange(range).getValues();`;
  }

  /**
   * Generate Drive create code
   */
  private generateDriveCreateCode(data: any): string {
    return `    const blob = Utilities.newBlob('${data.content || ''}', '${data.mimeType || 'text/plain'}', '${data.fileName || 'file.txt'}');
    const result = DriveApp.createFile(blob);`;
  }

  /**
   * Generate HTTP request code
   */
  private generateHttpRequestCode(data: any): string {
    const options = {
      method: data.method || 'GET',
      headers: data.headers || {},
      payload: data.payload || null
    };

    return `    const options = ${JSON.stringify(options, null, 6)};
    const response = UrlFetchApp.fetch('${data.url}', options);
    const result = {
      status: response.getResponseCode(),
      body: response.getContentText(),
      headers: response.getAllHeaders()
    };`;
  }

  /**
   * Generate condition code
   */
  private generateConditionCode(data: any): string {
    return `    const condition = ${data.condition || 'true'};
    const result = {
      condition: condition,
      branch: condition ? 'true' : 'false'
    };
    
    if (!condition) {
      Logger.log('Condition failed, skipping subsequent nodes');
      return;
    }`;
  }

  /**
   * Generate transform code
   */
  private generateTransformCode(data: any): string {
    return `    const inputData = context.results['${data.inputNode || ''}'] || {};
    const result = transformData(inputData, ${JSON.stringify(data.mapping || {})});`;
  }

  /**
   * Generate delay code
   */
  private generateDelayCode(data: any): string {
    const delayMs = data.delayMs || 1000;
    return `    Utilities.sleep(${delayMs});
    const result = { delayed: ${delayMs} };`;
  }

  /**
   * Generate helper files
   */
  private generateHelperFiles(graph: any, options: CompilerOptions): CompiledFile[] {
    const files: CompiledFile[] = [];

    // Runtime helpers
    files.push({
      name: 'RuntimeHelpers.js',
      content: `/**
 * Runtime helper functions
 */

function transformData(inputData, mapping) {
  const result = {};
  
  for (const [outputKey, inputPath] of Object.entries(mapping)) {
    const value = getNestedValue(inputData, inputPath);
    setNestedValue(result, outputKey, value);
  }
  
  return result;
}

function getNestedValue(obj, path) {
  return path.split('.').reduce((current, key) => current && current[key], obj);
}

function setNestedValue(obj, path, value) {
  const keys = path.split('.');
  const lastKey = keys.pop();
  const target = keys.reduce((current, key) => {
    if (!current[key]) current[key] = {};
    return current[key];
  }, obj);
  target[lastKey] = value;
}

function sendErrorNotification(error, projectName) {
  try {
    const subject = \`Error in \${projectName}\`;
    const body = \`An error occurred in your automation:

Error: \${error.toString()}
Time: \${new Date().toISOString()}
Project: \${projectName}

Please check your Google Apps Script logs for more details.\`;
    
    // Send to script owner (you can customize this)
    GmailApp.sendEmail(Session.getActiveUser().getEmail(), subject, body);
  } catch (e) {
    Logger.log('Failed to send error notification: ' + e.toString());
  }
}`,
      type: 'js'
    });

    // HTTP helpers
    files.push({
      name: 'HttpHelpers.js',
      content: `/**
 * HTTP request helpers
 */

function makeHttpRequest(url, options = {}) {
  const defaultOptions = {
    method: 'GET',
    headers: {
      'User-Agent': 'Apps Script Studio Automation'
    },
    muteHttpExceptions: true
  };
  
  const finalOptions = { ...defaultOptions, ...options };
  
  try {
    const response = UrlFetchApp.fetch(url, finalOptions);
    return {
      success: true,
      status: response.getResponseCode(),
      body: response.getContentText(),
      headers: response.getAllHeaders()
    };
  } catch (error) {
    return {
      success: false,
      error: error.toString()
    };
  }
}

function retryHttpRequest(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const result = makeHttpRequest(url, options);
      if (result.success) {
        return result;
      }
      lastError = result.error;
    } catch (error) {
      lastError = error.toString();
    }
    
    if (i < maxRetries - 1) {
      const delay = Math.pow(2, i) * 1000; // Exponential backoff
      Utilities.sleep(delay);
    }
  }
  
  throw new Error(\`HTTP request failed after \${maxRetries} retries: \${lastError}\`);
}`,
      type: 'js'
    });

    // Storage helpers
    files.push({
      name: 'StorageHelpers.js',
      content: `/**
 * Storage and state management helpers
 */

function saveState(key, value) {
  try {
    const serialized = JSON.stringify(value);
    PropertiesService.getScriptProperties().setProperty(key, serialized);
    return true;
  } catch (error) {
    Logger.log('Failed to save state: ' + error.toString());
    return false;
  }
}

function loadState(key, defaultValue = null) {
  try {
    const serialized = PropertiesService.getScriptProperties().getProperty(key);
    return serialized ? JSON.parse(serialized) : defaultValue;
  } catch (error) {
    Logger.log('Failed to load state: ' + error.toString());
    return defaultValue;
  }
}

function clearState(key) {
  try {
    PropertiesService.getScriptProperties().deleteProperty(key);
    return true;
  } catch (error) {
    Logger.log('Failed to clear state: ' + error.toString());
    return false;
  }
}

function generateUniqueId() {
  return Utilities.getUuid();
}

function getCurrentTimestamp() {
  return new Date().toISOString();
}`,
      type: 'js'
    });

    return files;
  }

  /**
   * Generate appsscript.json manifest
   */
  private generateManifest(graph: any, requiredScopes: string[], options: CompilerOptions): any {
    const triggers = graph.nodes?.filter((node: any) => node.type.startsWith('trigger.')) || [];
    
    const manifest = {
      timeZone: "America/New_York",
      dependencies: {
        enabledAdvancedServices: []
      },
      exceptionLogging: "STACKDRIVER",
      runtimeVersion: "V8",
      oauthScopes: requiredScopes.length > 0 ? requiredScopes : [
        "https://www.googleapis.com/auth/script.external_request"
      ]
    };

    // Add advanced services if needed
    const needsGmail = requiredScopes.some(scope => scope.includes('gmail'));
    const needsSheets = requiredScopes.some(scope => scope.includes('spreadsheets'));
    const needsDrive = requiredScopes.some(scope => scope.includes('drive'));

    if (needsGmail) {
      manifest.dependencies.enabledAdvancedServices.push({
        userSymbol: "Gmail",
        serviceId: "gmail",
        version: "v1"
      });
    }

    if (needsSheets) {
      manifest.dependencies.enabledAdvancedServices.push({
        userSymbol: "Sheets",
        serviceId: "sheets",
        version: "v4"
      });
    }

    if (needsDrive) {
      manifest.dependencies.enabledAdvancedServices.push({
        userSymbol: "Drive",
        serviceId: "drive",
        version: "v3"
      });
    }

    return manifest;
  }

  /**
   * Generate trigger setup code
   */
  private generateTriggerSetup(graph: any): string | null {
    const triggers = graph.nodes?.filter((node: any) => node.type.startsWith('trigger.')) || [];
    
    if (triggers.length === 0) {
      return null;
    }

    let code = `/**
 * Trigger setup functions
 * Run these functions once to set up your triggers
 */

function setupTriggers() {
  // Delete existing triggers
  const existingTriggers = ScriptApp.getProjectTriggers();
  existingTriggers.forEach(trigger => ScriptApp.deleteTrigger(trigger));
  
  Logger.log('Setting up triggers...');
  
`;

    triggers.forEach(trigger => {
      const data = trigger.data || {};
      
      switch (trigger.type) {
        case 'trigger.time.cron':
          code += `  // Time-based trigger: ${trigger.id}
  ScriptApp.newTrigger('runWorkflow')
    .timeBased()
    .everyMinutes(${data.intervalMinutes || 60})
    .create();
  
`;
          break;
          
        case 'trigger.webhook':
          code += `  // Webhook trigger setup (manual)
  // Deploy as web app and use the URL as webhook endpoint
  // The doPost function will handle incoming requests
  
`;
          break;
      }
    });

    code += `  Logger.log('Triggers set up successfully');
}

function doPost(e) {
  // Handle webhook requests
  try {
    const data = JSON.parse(e.postData.contents);
    return runWorkflow(data);
  } catch (error) {
    Logger.log('Webhook error: ' + error.toString());
    return ContentService.createTextOutput(JSON.stringify({
      error: error.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

function doGet(e) {
  // Handle GET requests (for testing)
  return ContentService.createTextOutput(JSON.stringify({
    status: 'OK',
    message: 'Automation endpoint is active',
    timestamp: new Date().toISOString()
  })).setMimeType(ContentService.MimeType.JSON);
}`;

    return code;
  }

  /**
   * Generate utility functions
   */
  private generateUtilityFunctions(options: CompilerOptions): string {
    return `
function logMessage(message, level = 'INFO') {
  const timestamp = new Date().toISOString();
  const logEntry = \`[\${timestamp}] [\${level}] \${message}\`;
  
  if (CONFIG.logging) {
    Logger.log(logEntry);
  }
}

function handleError(error, context = '') {
  const errorMessage = \`Error in \${context}: \${error.toString()}\`;
  logMessage(errorMessage, 'ERROR');
  
  if (CONFIG.errorHandling) {
    // You can customize error handling here
    // e.g., send notifications, save to sheet, etc.
  }
  
  throw error;
}`;
  }

  /**
   * Get execution order using topological sort
   */
  private getExecutionOrder(nodes: any[], edges: any[]): string[] {
    const adjList: Record<string, string[]> = {};
    const inDegree: Record<string, number> = {};
    
    // Initialize
    nodes.forEach(node => {
      adjList[node.id] = [];
      inDegree[node.id] = 0;
    });
    
    // Build adjacency list and in-degree count
    edges.forEach(edge => {
      adjList[edge.source].push(edge.target);
      inDegree[edge.target]++;
    });
    
    // Topological sort using Kahn's algorithm
    const queue: string[] = [];
    const result: string[] = [];
    
    // Find nodes with no incoming edges
    Object.keys(inDegree).forEach(nodeId => {
      if (inDegree[nodeId] === 0) {
        queue.push(nodeId);
      }
    });
    
    while (queue.length > 0) {
      const current = queue.shift()!;
      result.push(current);
      
      adjList[current].forEach(neighbor => {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      });
    }
    
    return result;
  }
}

// Export singleton instance
export const graphCompiler = new GraphCompiler();