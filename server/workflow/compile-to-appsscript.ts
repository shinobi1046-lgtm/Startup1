import { CompileResult, WorkflowGraph } from '../../common/workflow-types';

export function compileToAppsScript(graph: WorkflowGraph): CompileResult {
  const triggers   = graph.nodes.filter(n => n.type === 'trigger').length;
  const actions    = graph.nodes.filter(n => n.type === 'action').length;
  const transforms = graph.nodes.filter(n => n.type === 'transform').length;

  const code = emitCode(graph);
  const manifest = emitManifest();

  return {
    workflowId: graph.id,
    graph,
    stats: { nodes: graph.nodes.length, triggers, actions, transforms },
    files: [
      { path: 'Code.gs',        content: code },
      { path: 'appsscript.json', content: manifest },
    ],
  };
}

function emitManifest(): string {
  return JSON.stringify({
    timeZone: 'Etc/UTC',
    exceptionLogging: 'STACKDRIVER',
    oauthScopes: [
      'https://www.googleapis.com/auth/gmail.modify',
      'https://www.googleapis.com/auth/spreadsheets',
      'https://www.googleapis.com/auth/script.external_request',
      'https://www.googleapis.com/auth/calendar',
      'https://www.googleapis.com/auth/drive'
    ],
  }, null, 2);
}

function emitCode(graph: WorkflowGraph): string {
  const meta = graph.meta as any;
  
  // Generate code based on automation type
  const automationType = meta?.automationType || 'gmail_sheets';
  
  console.log(`🔧 Generating ${automationType} code for workflow: ${meta?.prompt}`);
  
  switch (automationType) {
    case 'drive_backup':
      return generateDriveBackupCode(graph, meta);
    case 'calendar_notifications':
      return generateCalendarNotificationCode(graph, meta);
    case 'slack_automation':
      return generateSlackAutomationCode(graph, meta);
    default:
      return generateGmailSheetsCode(graph, meta);
  }
}

function generateDriveBackupCode(graph: WorkflowGraph, meta: any): string {
  const triggerNode = graph.nodes.find(n => n.type === 'trigger');
  const actionNode = graph.nodes.find(n => n.type === 'action');
  
  const source = meta?.source || 'Drive folder';
  const destination = meta?.destination || 'Dropbox folder';
  const frequency = meta?.frequency || 5;
  
  return `
/**
 * Generated by Apps Script Studio
 * Workflow: ${meta?.prompt || 'Drive to Dropbox backup'}
 */
function main() {
  console.log('🚀 Starting Drive backup workflow...');
  
  try {
    // Get files from Drive folder
    console.log('📂 Scanning ${source} for files...');
    const folder = DriveApp.getFolderById('${triggerNode?.params?.folderId || 'your-folder-id'}');
    const files = folder.getFiles();
    
    const filesToBackup = [];
    while (files.hasNext()) {
      const file = files.next();
      filesToBackup.push({
        name: file.getName(),
        id: file.getId(),
        size: file.getSize(),
        mimeType: file.getBlob().getContentType()
      });
    }
    
    console.log(\`Found \${filesToBackup.length} files to backup\`);
    
    if (filesToBackup.length === 0) {
      console.log('No files found to backup');
      return;
    }
    
    // Backup to Dropbox (using UrlFetchApp)
    filesToBackup.forEach(fileInfo => {
      console.log(\`📤 Backing up: \${fileInfo.name}\`);
      
      const file = DriveApp.getFileById(fileInfo.id);
      const fileBlob = file.getBlob();
      
      // Note: This requires Dropbox API token in PropertiesService
      const dropboxToken = PropertiesService.getScriptProperties().getProperty('DROPBOX_TOKEN');
      
      if (dropboxToken) {
        const response = UrlFetchApp.fetch('https://content.dropboxapi.com/2/files/upload', {
          method: 'POST',
          headers: {
            'Authorization': \`Bearer \${dropboxToken}\`,
            'Content-Type': 'application/octet-stream',
            'Dropbox-API-Arg': JSON.stringify({
              path: \`${destination}/\${fileInfo.name}\`,
              mode: 'add',
              autorename: true
            })
          },
          payload: fileBlob.getBytes()
        });
        
        if (response.getResponseCode() === 200) {
          console.log(\`✅ Successfully backed up: \${fileInfo.name}\`);
        } else {
          console.error(\`❌ Failed to backup: \${fileInfo.name}\`);
        }
      } else {
        console.error('❌ Dropbox token not configured in PropertiesService');
      }
    });
    
    console.log('✅ Backup workflow completed');
    
  } catch (error) {
    console.error('❌ Backup workflow failed:', error);
    throw error;
  }
}

function setupTriggers() {
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') ScriptApp.deleteTrigger(tr);
  });
  
  ScriptApp.newTrigger('main')
    .timeBased()
    .everyWeeks(1)
    .onWeekDay(ScriptApp.WeekDay.SUNDAY)
    .create();
    
  console.log('⏰ Trigger set up to run weekly on Sunday');
}

function testWorkflow() {
  console.log('🧪 Testing backup workflow manually...');
  main();
}
`.trim();
}

function generateCalendarNotificationCode(graph: WorkflowGraph, meta: any): string {
  const actionNode = graph.nodes.find(n => n.type === 'action');
  
  const channel = actionNode?.params?.channel || 'general';
  const message = actionNode?.params?.message || 'Happy Birthday! 🎉';
  
  return `
/**
 * Generated by Apps Script Studio
 * Workflow: ${meta?.prompt || 'Calendar birthday notifications'}
 */
function main() {
  console.log('🚀 Starting birthday notification workflow...');
  
  try {
    const today = new Date();
    const calendar = CalendarApp.getDefaultCalendar();
    const events = calendar.getEventsForDay(today);
    
    console.log(\`📅 Found \${events.length} events for today\`);
    
    const birthdayEvents = events.filter(event => {
      const title = event.getTitle().toLowerCase();
      return title.includes('birthday') || title.includes('bday') || title.includes('🎂');
    });
    
    console.log(\`🎂 Found \${birthdayEvents.length} birthday events\`);
    
    if (birthdayEvents.length === 0) {
      console.log('No birthdays today');
      return;
    }
    
    birthdayEvents.forEach(event => {
      const personName = extractNameFromTitle(event.getTitle());
      const customMessage = \`${message} \${personName}!\`;
      
      console.log(\`📤 Sending birthday message for: \${personName}\`);
      
      const slackWebhook = PropertiesService.getScriptProperties().getProperty('SLACK_WEBHOOK');
      
      if (slackWebhook) {
        const payload = {
          channel: '#${channel}',
          text: customMessage,
          username: 'Birthday Bot',
          icon_emoji: ':birthday:'
        };
        
        const response = UrlFetchApp.fetch(slackWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          payload: JSON.stringify(payload)
        });
        
        if (response.getResponseCode() === 200) {
          console.log(\`✅ Birthday message sent for: \${personName}\`);
        } else {
          console.error(\`❌ Failed to send message for: \${personName}\`);
        }
      } else {
        console.error('❌ Slack webhook not configured');
      }
    });
    
    console.log('✅ Birthday notification workflow completed');
    
  } catch (error) {
    console.error('❌ Birthday workflow failed:', error);
    throw error;
  }
}

function extractNameFromTitle(title) {
  const cleaned = title.replace(/birthday|bday|🎂/gi, '').trim();
  return cleaned || 'Someone';
}

function setupTriggers() {
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') ScriptApp.deleteTrigger(tr);
  });
  
  ScriptApp.newTrigger('main')
    .timeBased()
    .everyDays(1)
    .atHour(9)
    .create();
    
  console.log('⏰ Trigger set up to run daily at 9 AM');
}

function testWorkflow() {
  console.log('🧪 Testing birthday workflow manually...');
  main();
}
`.trim();
}

function generateSlackAutomationCode(graph: WorkflowGraph, meta: any): string {
  return generateCalendarNotificationCode(graph, meta);
}

function generateGmailSheetsCode(graph: WorkflowGraph, meta: any): string {
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  let mainFunction = `/**
 * Generated by Apps Script Studio
 * Workflow: ${meta?.prompt || 'Gmail to Sheets automation'}
 */
function main() {
  console.log('🚀 Starting Gmail to Sheets workflow...');
  
  try {
`;

  triggerNodes.forEach(trigger => {
    if (trigger.app === 'gmail-enhanced' || trigger.app === 'gmail') {
      const query = trigger.params?.query || 'in:inbox is:unread';
      const maxResults = trigger.params?.maxResults || 50;
      
      mainFunction += `
    console.log('📧 Searching Gmail with query: ${query}');
    const threads = GmailApp.search(${JSON.stringify(query)}, 0, ${maxResults});
    console.log(\`Found \${threads.length} email threads\`);
    
    if (!threads.length) {
      console.log('No emails found matching criteria');
      return;
    }
    
    const emailData = [];
`;
    }
  });

  transformNodes.forEach(transform => {
    if (transform.op === 'extract_fields') {
      const fields = transform.params?.fields || ['subject', 'from', 'date'];
      
      mainFunction += `
    threads.forEach(thread => {
      const messages = thread.getMessages();
      messages.forEach(message => {
        const extractedData = {`;
        
      fields.forEach(field => {
        switch(field) {
          case 'subject':
            mainFunction += `
          subject: message.getSubject() || '',`;
            break;
          case 'from':
            mainFunction += `
          from: message.getFrom() || '',`;
            break;
          case 'date':
            mainFunction += `
          date: Utilities.formatDate(message.getDate(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm'),`;
            break;
          case 'body':
            mainFunction += `
          body: (message.getPlainBody() || '').substring(0, 500),`;
            break;
        }
      });
      
      mainFunction += `
        };
        emailData.push(extractedData);
      });
    });
    
    console.log(\`Extracted data from \${emailData.length} emails\`);
`;
    }
  });

  actionNodes.forEach(action => {
    if (action.app === 'google-sheets-enhanced' || action.app === 'sheets') {
      const sheetId = action.params?.spreadsheetId || meta?.spreadsheetId;
      const sheetName = action.params?.sheet || meta?.sheetName || 'Sheet1';
      
      mainFunction += `
    if (emailData.length > 0) {
      console.log('📊 Writing to Google Sheets...');
      const ss = SpreadsheetApp.openById(${JSON.stringify(sheetId)});
      const sheet = ss.getSheetByName(${JSON.stringify(sheetName)}) || ss.getSheets()[0];
      
      emailData.forEach(data => {
        const row = [
          data.subject || '',
          data.from || '',
          data.date || '',
          data.body || ''
        ];
        sheet.appendRow(row);
        console.log(\`Added row: \${data.subject}\`);
      });
      
      console.log(\`✅ Successfully added \${emailData.length} rows to ${sheetName}\`);
    }
`;
    }
  });

  mainFunction += `
  } catch (error) {
    console.error('❌ Workflow execution failed:', error);
    throw error;
  }
}`;

  const triggerSetup = triggerNodes.map(trigger => {
    if (trigger.params?.frequency) {
      return `
function setupTriggers() {
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') {
      ScriptApp.deleteTrigger(tr);
    }
  });
  
  ScriptApp.newTrigger('main')
    .timeBased()
    .everyMinutes(${trigger.params.frequency})
    .create();
    
  console.log('⏰ Trigger set up to run every ${trigger.params.frequency} minutes');
}`;
    }
    return '';
  }).join('');

  const testFunction = `
function testWorkflow() {
  console.log('🧪 Testing Gmail to Sheets workflow manually...');
  main();
}`;

  return (mainFunction + triggerSetup + testFunction).trim();
}